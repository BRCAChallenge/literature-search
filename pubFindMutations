#!/usr/bin/env python

# load default python packages
import logging, optparse, sys, glob, gzip, gdbm, marshal, zlib
from os.path import join, basename, isfile, dirname, abspath, splitext, isdir
from collections import defaultdict, Counter, namedtuple

# I highly recommend installing re2, it's way faster than re
# we fallback to re just in case
#try:
    #import re2 as re
#except ImportError:
import re

# add <scriptDir>/lib/ to package search path
sys.path.insert(0, join(dirname(abspath(__file__)), "lib"))

import pubGeneric, maxCommon, pubConf, maxbio, pubAlg, maxTables, pslMapBed
import kent.psl, kent.pslTransMap

geneData = None

mutFields = \
    (
    "patType",     # the type of the patterns (sub, del, ins)
    "seqType",     # the seqType of the patterns, dna or protein
    "hgvsProt",    # hgvs on protein, can be multiple, separated with |
    "hgvsCdna",    # hgvs on cdna, can be multiple, separated with |
    "protStart",   # the protein start position, if protein
    "protEnd",     # the protein end position, if protein
    "origAa",      # wild type amino acid seq
    "mutAa",       # mutated amino acid seq
    "texts",        # mutation match in text
    #"mutSupport",  # prot, dna, protDna
    #"mutCount",    # how often was this mutation mentioned?

    "geneSymbol",  # symbol of gene
    "geneType",    # why was this gene selected (entrez, symNearby, symInTitle, symInAbstract)
    "entrezId",    # entrez ID of gene
    "protIds",     # IDs of matching proteins, comma-sep
    "geneStarts",  # start positions of gene mentions in document
    "geneEnds",    # end positions of gene mentions in document

    "mutPatNames",    # the names of the patterns that matched, separated by |
    "mutStarts",   # start positions of mutation pattern matches in document
    "mutEnds",     # end positions of mutation pattern matches in document
    "mutSnippets",  # the phrases around the mutation mentions, separated by "|"
    "geneSnippets"  # the phrases around the gene mentions, separated by "|"
    )

# fields of the output file
MutRec = namedtuple("mutation_desc", mutFields)

# long form -> one-letter conversion table for amino acids
threeToOne = \
    {'Cys': 'C', 'Asp': 'D', 'Ser': 'S', 'Gln': 'Q', 'Lys': 'K',
     'Ile': 'I', 'Pro': 'P', 'Thr': 'T', 'Phe': 'F', 'Asn': 'N',
     'Gly': 'G', 'His': 'H', 'Leu': 'L', 'Arg': 'R', 'Trp': 'W',
     'Ala': 'A', 'Val':'V',  'Glu': 'E', 'Tyr': 'Y', 'Met': 'M',
     'Sec': 'U',  # Sec = sometimes used as amino acid (same as Ter)
     'Ter': '*',   # the termination codon
     'Stop': '*',   # the termination codon
     'Alanine'       : 'A',
     'Aspartic acid' : 'B',
     'Asparagine'    : 'B',
     'Cysteine'      : 'C',
     'Aspartic Acid' : 'D',
     'Glutamic Acid' : 'E',
     'Phenylalanine' : 'F',
     'Glycine'       : 'G',
     'Histidine'     : 'H',
     'Isoleucine'    : 'I',
     'Lysine'        : 'K',
     'Leucine'       : 'L',
     'Methionine'    : 'M',
     'Asparagine'    : 'N',
     'Proline'       : 'P',
     'Glutamine'     : 'Q',
     'Arginine'      : 'R',
     'Serine'        : 'S',
     'Threonine'     : 'T',
     'Valine'        : 'V',
     'Tryptophan'    : 'W',
     'Any'           : 'X',
     'Tyrosine'      : 'Y',
     'Glutamine'     : 'Z',
     'Glutamic Acid' : 'Z'
     }

# same but lower case
threeToOneLower = dict([[k.lower(),v] for k,v in threeToOne.items()])
# one-letter -> three-letter conversion table for amino acids
oneToThree = \
    {'C':'Cys', 'D':'Asp', 'S':'Ser', 'Q':'Gln', 'K':'Lys',
     'I':'Ile', 'P':'Pro', 'T':'Thr', 'F':'Phe', 'N':'Asn',
     'G':'Gly', 'H':'His', 'L':'Leu', 'R':'Arg', 'W':'Trp',
     'A':'Ala', 'V':'Val', 'E':'Glu', 'Y':'Tyr', 'M':'Met',
     'U':'Sec', '*':'Stop','X':'Any'} 

# from amino acid to all possible codons
aaToDna = {'A': ['GCA', 'GCC', 'GCG', 'GCT'],
 'C': ['TGT', 'TGC'],
 'D': ['GAT', 'GAC'],
 'E': ['GAG', 'GAA'],
 'F': ['TTT', 'TTC'],
 'G': ['GGT', 'GGG', 'GGA', 'GGC'],
 'H': ['CAT', 'CAC'],
 'I': ['ATC', 'ATA', 'ATT'],
 'K': ['AAG', 'AAA'],
 'L': ['CTC', 'CTG', 'CTA', 'CTT', 'TTA', 'TTG'],
 'M': ['ATG'],
 'N': ['AAC', 'AAT'],
 'P': ['CCT', 'CCA', 'CCG', 'CCC'],
 'Q': ['CAG', 'CAA'],
 'R': ['AGG', 'AGA', 'CGA', 'CGC', 'CGG', 'CGT'],
 'S': ['AGC', 'AGT', 'TCG', 'TCA', 'TCC', 'TCT'],
 'T': ['ACC', 'ACA', 'ACG', 'ACT'],
 'V': ['GTA', 'GTC', 'GTG', 'GTT'],
 'W': ['TGG'],
 'Y': ['TAT', 'TAC'],
 '*': ['TAG', 'TAA', 'TGA']}

# these look like mutations but are definitely not mutations
# satellites?
blackList = [
    ("D", 11, "S"),
    ("D", 12, "S"),
    ("D", 13, "S"),
    ("D", 14, "S"),
    ("D", 15, "S"),
    ("D", 16, "S")]

# ==== FUNCTIONS =====
def indexGenes(upAnnots):
    """ given rows from annotation file, return extId, counts of uniprot accession and 
      dict with uniprot accession to list of annotations """
    upCounts = Counter()
    accToAnnots = defaultdict(list)
    assert(len(upAnnots)>0)
    extId = None
    for up in upAnnots:
        upCounts.update([up.uniProtAcc])
        accToAnnots[up.uniProtAcc].append(up)
        extId = up.externalId
    return extId, upCounts, accToAnnots

def findSeqs(seqs, accs, pos, res):
    " return all uniprot accessions from accs with at least one variant with residue at pos "
    matchSeqs = []
    for acc in accs:
        isoSeqs = seqs[acc]
        for seqId, seq in isoSeqs:
            if pos < len(seq) and seq[pos]==res:
                matchSeqs.append(seqId)
                break
    return matchSeqs

def parseRegex(mutDataDir):
    # read regexes, translate placeholders to long form and compile
    replDict = {
    "sep"         : r"""(?:^|[\s\(\[\'"/,\-])""",
    "fromPos"     : r'(?P<fromPos>[1-9][0-9]+)',
    "toPos"       : r'(?P<toPos>[1-9][0-9]+)',
    "pos"         : r'(?P<pos>[1-9][0-9]+)',
    "origAaShort" : r'(?P<origAaShort>[CISQMNPKDTFAGHLRWVEY])',
    "mutAaShort"  : r'(?P<mutAaShort>[CISQMNPKDTFAGHLRWVEY*])',
    "origAaLong"  : r'(?P<origAaLong>(CYS|ILE|SER|GLN|MET|ASN|PRO|LYS|ASP|THR|PHE|ALA|GLY|HIS|LEU|ARG|TRP|VAL|GLU|TYR|TER|GLUTAMINE|GLUTAMIC ACID|LEUCINE|VALINE|ISOLEUCINE|LYSINE|ALANINE|GLYCINE|ASPARTATE|METHIONINE|THREONINE|HISTIDINE|ASPARTIC ACID|ARGININE|ASPARAGINE|TRYPTOPHAN|PROLINE|PHENYLALANINE|CYSTEINE|SERINE|GLUTAMATE|TYROSINE|STOP))',
    "mutAaLong"  : r'(?P<mutAaLong>(CYS|ILE|SER|GLN|MET|ASN|PRO|LYS|ASP|THR|PHE|ALA|GLY|HIS|LEU|ARG|TRP|VAL|GLU|TYR|TER|GLUTAMINE|GLUTAMIC ACID|LEUCINE|VALINE|ISOLEUCINE|LYSINE|ALANINE|GLYCINE|ASPARTATE|METHIONINE|THREONINE|HISTIDINE|ASPARTIC ACID|ARGININE|ASPARAGINE|TRYPTOPHAN|PROLINE|PHENYLALANINE|CYSTEINE|SERINE|GLUTAMATE|TYROSINE|STOP))',
    "dna"         : r'(?P<dna>[actgACTG])',
    "origDna"     : r'(?P<origDna>[actgACTG])',
    "mutDna"      : r'(?P<mutDna>[actgACTG])',
    "fs"          : r'(?P<fs>(fs\*?[0-9]*)|fs\*|fs|)?',
    }
    regexTab = join(mutDataDir, "regex.txt")
    logging.info("Parsing regexes from %s" % regexTab)
    regexList = []
    counts = defaultdict(int)
    for row in maxCommon.iterTsvRows(regexTab):
        logging.debug("Translating %s" % row.pat)
        patName = row.patName
        if patName=="":
            patName = row.pat
        patFull = row.pat.format(**replDict)
        logging.debug("full pattern is %s" % patFull)
        flags = 0
        if "Long}" in row.pat:
            flags = re.IGNORECASE
            logging.debug("ignoring case for this pattern")
        patComp = re.compile(patFull, flags=flags)
        regexList.append((row.seqType, row.mutType, patName, patComp))
        counts[(row.seqType, row.mutType)] += 1

    for regexType, count in counts.iteritems():
            logging.info("regexType %s, Found %d regexes" % (str(regexType), count))
    return regexList

def openData(mutDataDir, taxId):
    " open db files, compile patterns, parse input as far as possible "
    fname = join(mutDataDir, "uniprot.tab.marshal")
    logging.info("Reading uniprot data from %s" % fname)
    data = marshal.load(open(fname))

    fname = join(mutDataDir, "entrezToRefseq.%s.tab.marshal" % taxId)
    logging.info("Reading entrez data from %s" % fname)
    entrezRefseq = marshal.load(open(fname))

    fname = join(mutDataDir, "pmid2entrez.dbm")
    logging.info("opening %s" % fname)
    pmid2entrez = gdbm.open(fname, "r")
    
    fname = join(mutDataDir, "refseq.dbm")
    logging.info("opening %s" % fname)
    seqs = gdbm.open(fname, "r")
    
    # parse and compile regexes to list (seqType, mutType, patName, pat) 
    regexes = parseRegex(mutDataDir)
        
    ret = {}
    ret["entrez2up"] = data[taxId]["entrezToUp"]
    ret["upSeqs"] = data[taxId]["upSeqs"]
    ret["pmid2entrez"] = pmid2entrez
    ret["upToSym"] = data[taxId]["upToSym"]
    ret["seqs"] = seqs
    ret["entrez2refseqs"] = entrezRefseq["entrez2refseqs"]
    ret["entrez2refprots"] = entrezRefseq["entrez2refprots"]
    ret["entrez2sym"] = entrezRefseq["entrez2sym"]

    return ret, regexes

VariantFields = ["seqType", "start", "end", "orig", "mut"]
Variant = namedtuple("Variant", VariantFields)
Mention = namedtuple("Mention", "patName,start,end")

def parseMatch(match, patName):
    groups = match.groupdict()
    # grab long and short versions of amino acid
    if "origAaShort" in groups:
        origSeq = groups["origAaShort"]
        seqType = "aa"
    if "origAaLong" in groups:
        origSeq = threeToOneLower[groups["origAaLong"].lower()]
        seqType = "aa"
    if "mutAaShort" in groups:
        mutSeq = groups["mutAaShort"]
        seqType = "aa"
    if "mutAaLong" in groups:
        mutSeq = threeToOneLower[groups["mutAaLong"].lower()]
        seqType = "aa"
    if "origDna" in groups:
        origSeq = groups["origDna"]
        seqType = "dna"
    if "mutDna" in groups:
        mutSeq = groups["mutDna"]
        seqType = "dna"

    if "fromPos" in groups:
        protStart = int(groups["fromPos"])
    if "toPos" in groups:
        protEnd = int(groups["toPos"])
    else:
        pos = int(groups["pos"])
        protStart = pos
        protEnd = pos+1

    var = Variant(seqType, protStart, protEnd, origSeq, mutSeq)

    start = match.start()
    end = match.end()
    mention = Mention(patName, start, end)

    if (origSeq, protStart, mutSeq) in blackList:
        logging.debug("Variant %s,%d,%s is blacklisted" % (origSeq, protStart, mutSeq))
        return None, None
    else:
        return var, mention

def findGenes(db, pmid, abstract, title, text):
    """ return dict where [entrez|title|abstract|text] = list of gene mentions 

    """
    geneTypes = {}
    if pmid in db["pmid2entrez"]:
        entrezGenes = db["pmid2entrez"][pmid].split(",")
        entrezGenes = [int(x) for x in entrezGenes]
        geneTypes["entrez"] = entrezGenes

    return geneTypes

def findMutations(regexes, text):
    """ put mutation mentions from document together into dicts indexed by normal form 
        return dict variant-> list of mentions
    """
    muts = defaultdict(list)
    for seqType, mutType, patName, pat in regexes:
        if mutType=="sub":
            for match in pat.finditer(text):
                logging.debug("Match: Pattern %s, text %s" % (patName, match.groups()))
                variant, mention = parseMatch(match, patName)
                if variant!=None:
                    muts[variant].append(mention)
                    debugSnip = pubAlg.getSnippet(text, mention.start, mention.end, maxContext=10)
                    varStr = ",".join([str(x) for x in variant])
                    logging.debug("Found Variant: %s = %s" % (varStr, debugSnip))
    return muts
    
def makeHgvsStr(seqType, seqId, origSeq, pos, mutSeq):
    if seqType=="p":
        desc = "%s:p.%s%d%s" % (seqId, oneToThree[origSeq], pos, oneToThree[mutSeq])
    elif seqType=="c":
        desc = "%s:c.%d%s>%s" % (seqId, pos, origSeq, mutSeq)
    return desc
  
def makeHgvsSub(seqIds, mut):
   ret = []
   for seqId in seqIds:
       hgvsStr = makeHgvsStr("p", seqId, mut.orig, mut.start+1, mut.mut)
       ret.append(hgvsStr)
   return "|".join(ret)

def indexPsls(fname):
    psl = kent.psl.pslLoadAll(fname)
    pslIdx = {}
    while psl:
        pslIdx[str(psl.contents.qName)] = psl
        psl = psl.contents.next
    # memory leak, struct behind p not freed
    return pslIdx
    
protMap = pslMapBed.indexPsls("toRefseq/protMap/work/protToTrans.psl", isProt=True)
#protMap = indexPsls("toRefseq/protMap/work/protToTrans.psl")
#protMap = indexPsls("temp.psl")

def firstDiff(str1, str2):
    """Return pos and letters where strings differ. Returns None if more than one diff char"""
    assert(len(str1)==len(str2))
    if str1==str2:
        return None
    diffs = 0
    i = 0
    for ch1, ch2 in zip(str1, str2):
        if ch1 != ch2:
            diffs += 1
            diffCh1 = ch1
            diffCh2 = ch2
            diffPos = i
        i+=1
    if diffs>1 or diffs==0:
        return None
    else:
        return (i, ch1, ch2)

def aaChangeToDnaChange(origAa, mutAa):
    """ figure out which nucleotides were possibly mutated by an amino acid change 
    return list of (relPos, oldNucl, newNucl)
    """
    ret = []
    origDnas = aaToDna[origAa]
    mutDnas  = aaToDna[mutAa]
    for origDna in origDnas:
        for mutDna in mutDnas:
            diffTuple = firstDiff(origDna, mutDna)
            if diffTuple!=None:
                ret.append( diffTuple )
    return ret

def bedToPsl(chrom, chromSize, start, end, name):
    qSize = end-start
    psl = kent.psl.pslNew(name, qSize, 0, qSize, chrom, chromSize, start, end, "+", 1, 0)
    psl.contents.match = qSize
    psl.contents.qStarts[0]=0
    psl.contents.tStarts[0]=start
    psl.contents.blockSizes[0]=(end-start)
    psl.contents.blockCount=1
    kent.psl.pslWriteAll(psl, "temp.psl", 0)
    return psl
    
def hgvsMapProtToCdna(protIds, mut):
    " map mutation through psl to get cdna positions "
    ret = []
    maker = pslMapBed.PslMapBedMaker()
    for protId in protIds:
        pslList = protMap[protId]
        assert(len(pslList)==1)
        psl = pslList[0]
        #print psl
        #print mut.start*3, mut.end*3
        print dir(psl)
        print psl.blocks
        print mut.start*3, mut.end*3
        bed = maker.mapQuery(psl, mut.start*3, mut.end*3)
        print bed
        #print bed
        liftStart = int(bed[1])
        liftEnd   = int(bed[2])
        tName    = bed[0]
        #fakePsl = bedToPsl(protId, 860, mut.start, mut.end, "test")
        #mappedPsl = kent.pslTransMap.pslTransMap(0, fakePsl, mapPsl)
        #if mappedPsl:
        #    tName = mappedPsl.contents.tName
        #    tStart = mappedPsl.contents.tStart
        #    tEnd = mappedPsl.contents.tEnd
        hgvsStr = makeHgvsStr("c", tName, mut.orig, liftStart, mut.mut)
        assert(3*(mut.end-mut.start) == liftEnd-liftStart) # can't do if over splice site
        ret.append(hgvsStr)
    return "|".join(ret)

class SeqVariant(object):
    " a variant grounded on a sequence, with pieces from the text "
    __slots__ = mutFields

    def __init__(self, mut, entrezGene, protIds, geneSym, mentions, text):
        self.patType = "sub"
        self.seqType = "prot"
        self.protStart  = mut.start
        self.protEnd    = mut.end
        self.origAa     = mut.orig
        self.mutAa      = mut.mut
        self.geneSymbol = geneSym
        self.entrezId   = entrezGene
        self.protIds    = "|".join(protIds)
        self.hgvsProt   = makeHgvsSub(protIds, mut)
        self.hgvsCdna   = hgvsMapProtToCdna(protIds, mut)
        self.geneType   = "entrez"
        self.geneStarts = ""
        self.geneEnds   = ""
        self.geneSnippets = ""

        mutStarts = []
        mutEnds = []
        snippets = []
        patNames = []
        texts = []
        for m in mentions:
            mutStarts.append(str(m.start))
            mutEnds.append(str(m.end))
            snippets.append(pubAlg.getSnippet(text, m.start, m.end).replace("|"," "))
            patNames.append(m.patName)
            texts.append(text[m.start:m.end].strip("() -;,."))

        self.mutStarts = ",".join(mutStarts)
        self.mutEnds   = ",".join(mutEnds)
        self.mutPatNames= "|".join(patNames)
        self.mutSnippets = "|".join(snippets)
        self.texts = "|".join(texts)

    def asRow(self):
        row =[]
        for i in self.__slots__:
            row.append(str(getattr(self, i)))
        return row
        
    def __repr__(self):
        return ",".join(self.asRow())
        
def ungroundedMutsToFakeSeqVariants(ungroundedMuts, text):
    """ convert mutations that could not be grounded to "fake" variants
        that not located on any sequence but are easy to write to a file
    """
    muts = []
    for mut, mentions in ungroundedMuts.iteritems():
        muts.append(SeqVariant(mut, "", [], "", mentions, text))
    return muts

def getSeq(seqId):
    " use global seq store to get seq "
    comprSeq = geneData["seqs"][seqId]
    seq = zlib.decompress(comprSeq)
    return seq

def isSeqCorrect(protId, mut):
    " check if wild type sequence in protein corresponds to mutation positions "
    protStart = mut.start-1 # uniprot is 1-based, we are 0-based
    protEnd   = mut.end -1
    seq = getSeq(protId)

    if not protEnd<=len(seq):
        logging.debug("sequence %s is too short" % protId)
        return False
    
    aaSeq = seq[protStart:protEnd]
    if aaSeq==mut.orig:
        logging.debug("Seq match: Found %s at pos %d-%d in seq %s" % \
            (aaSeq, protStart, protEnd, protId))
        return True
    else:
        logging.debug("No seq match: Need %s, but found %s at pos %d-%d in seq %s" % \
            (mut.orig, aaSeq, protStart, protEnd, protId))
        return False

def entrezToRefseqProts(entrezGene):
    " map entrez gene to refseq prots like NP_xxx "
    if entrezGene not in geneData["entrez2refprots"]:
        logging.debug("gene %d is not valid or not in selected species")
        return None, None
    geneSym = geneData["entrez2sym"][entrezGene]
    protIds = geneData["entrez2refprots"][entrezGene]
    logging.debug("Entrez gene %s/%s is mapped to proteins %s" % \
        (entrezGene, geneSym, ",".join(protIds)))
    return geneSym, protIds

def entrezToUniProt(entrezGene):
    #geneSym = geneData["upToSym"][protId]
    #seq = geneData["upSeqs"][protId]
    pass

def groundMutations(text, mutations, genes):
    """ ground mutations onto genes and return """
    groundedMuts = []
    ungroundedMuts = {}

    for mut, mentions in mutations.iteritems():
        logging.debug("Trying to validate mutation %s onto genes %s" % (mut, genes))
        # try all entrez genes in article
        for entrezGene in genes:
            logging.debug("Trying entrez gene %s" % entrezGene)
            geneSym, protIds = entrezToRefseqProts(entrezGene)
            if protIds==None:
                continue

            # try all protein seqs
            foundProtIds = []
            for protId in protIds:
                if isSeqCorrect(protId, mut):
                    foundProtIds.append(protId)

            if len(foundProtIds)!=0:
                groundedMuts.append(SeqVariant(mut, entrezGene, foundProtIds, geneSym, mentions, text))
            else:
                ungroundedMuts[mut] = mentions

    ungroundedMuts = ungroundedMutsToFakeSeqVariants(ungroundedMuts, text)
    return groundedMuts, ungroundedMuts

def writeHeaders(outFh):
    prefixHeaders = ["docId", "isConfirmed"]
    outFh.write("\t".join(prefixHeaders)+"\t"+"\t".join(mutFields)+"\n")

def readFile(inFname):
    logging.info("Reading file %s" % inFname)
    text = open(inFname).read()
    title = ""
    abstract = ""
    pmid  = splitext(basename(inFname))[0]
    return pmid, title, abstract, text

def findInLocalFile(inFname, writer, regexes):
    pmid, title, abstract, text = readFile(inFname)
    muts  = findMutations(regexes, text)
    genes = findGenes(geneData, pmid, title, abstract, text)
    if not "entrez" in genes:
        logging.info("No genes for %s" % inFname)
        genes = []
        groundedMuts = []
        ungroundMuts = ungroundedMutsToFakeSeqVariants(muts, text)
    else:
        genes = genes["entrez"]
        groundedMuts, ungroundMuts = groundMutations(text, muts, genes)
    writer.writeMuts(pmid, "confirmed", groundedMuts)
    writer.writeMuts(pmid, "notConfirmed", ungroundMuts)

def findInLocalDir(inDir, writer, regexes):
    for fname in glob.glob(join(inDir, "*.txt")):
        logging.info(fname)
        findInLocalFile(fname, writer, regexes)

class OutputWriter(object):
    def __init__(self, outFname):
        self.outFh = maxTables.openFile(outFname, "w")
        writeHeaders(self.outFh)

    def writeMuts(self, docId, status, muts):
        for mut in muts:
            prefixFields=[docId, status]
            self.outFh.write("\t".join(prefixFields)+"\t")
            row = mut.asRow()
            row = [r.replace("\n", " ") for r in row]
            row = [r.replace("\t", " ") for r in row]
            self.outFh.write("\t".join(row))
            self.outFh.write("\n")

    def close(self):
        self.outFh.close()
        
def main(args, options):
    if options.test:
        import doctest
        doctest.testmod()
        sys.exit(0)

    pubGeneric.setupLogging("", options)
    mutDataDir = join(pubConf.staticDataDir, "mutFinder")

    inFname, outFname = args

    global geneData
    geneData, regexes = openData(mutDataDir, 9606)

    writer = OutputWriter(outFname)

    if isfile(inFname):
        findInLocalFile(inFname, writer, regexes)
    elif isdir(inFname):
        findInLocalDir(inFname, writer, regexes)
    else:
        assert(False)

    logging.info("Wrote output to %s" % outFname)

    writer.close()

    #protSizeFname = join(mutDataDir, "uniprot.%s.prot.fa.size")
    #mapAny(protSizeFname, outFname


# === COMMAND LINE INTERFACE, OPTIONS AND HELP ===
parser = optparse.OptionParser("""usage: %prog [options] annotDir - use all possible means to resolve mutations""")

parser.add_option("-d", "--debug", dest="debug", action="store_true", help="show debug messages")
parser.add_option("-v", "--verbose", dest="verbose", action="store_true", help="show more debug messages")
parser.add_option("-t", "--test", dest="test", action="store_true", help="run tests")
(options, args) = parser.parse_args()

if args==[] and not options.test:
    parser.print_help()
    exit(1)

pubGeneric.setupLogging(__file__, options)
main(args, options)

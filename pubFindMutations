#!/usr/bin/env python

# load default python packages
import logging, optparse, sys, glob, gzip, gdbm, marshal, zlib, copy
from os.path import join, basename, isfile, dirname, abspath, splitext, isdir
from collections import defaultdict, Counter, namedtuple
from pycbio.hgdata.Psl import Psl

# I highly recommend installing re2, it's way faster than re
# we fallback to re just in case
#try:
    #import re2 as re
#except ImportError:
import re

# add <scriptDir>/lib/ to package search path
sys.path.insert(0, join(dirname(abspath(__file__)), "lib"))

import pubGeneric, maxCommon, pubConf, maxbio, pubAlg, maxTables, pslMapBed
#import kent.psl, kent.pslTransMap

geneData = None

""" A mapped variant is a type-range-sequence combination from a text, 
    can be located on none, one or multiple types of sequences
    All positions are 0-based
"""
VariantFields = [
    "mutType", # sub, del or ins
    "seqType", # prot or dna or protdna if not sure
    "seqId",  # protein or nucleotide accession
    "geneId", # entrez gene id, if found nearby in text
    "start",  # original position in text
    "end",    # ?
    "origSeq", # wild type seq, used for sub and del
    "mutSeq",  # mutated seq, used for sub and ins
    ]

# A completely resolved mutation
mutFields = \
    (
    "varId",       # uniqueId
    "patType",     # the type of the patterns (sub, del, ins)
    "chrom",       # chromosome
    "start",       # on chrom
    "end",         # on chrom
    "hgvsProt",    # hgvs on protein, can be multiple, separated with |
    "hgvsCoding",  # hgvs on cdna, can be multiple, separated with |
    "hgvsRna",     # hgvs on refseq, separated by "|"
    "protId",      # the protein ID that was used for the first mapping
    "texts",        # mutation match in text
    #"mutSupport",  # prot, dna, protDna
    #"mutCount",    # how often was this mutation mentioned?

    "geneSymbol",  # symbol of gene
    "geneType",    # why was this gene selected (entrez, symNearby, symInTitle, symInAbstract)
    "entrezId",    # entrez ID of gene
    "geneStarts",  # start positions of gene mentions in document
    "geneEnds",    # end positions of gene mentions in document

    "seqType",     # the seqType of the patterns, dna or protein
    "mutPatNames",    # the names of the patterns that matched, separated by |
    "mutStarts",   # start positions of mutation pattern matches in document
    "mutEnds",     # end positions of mutation pattern matches in document
    "mutSnippets",  # the phrases around the mutation mentions, separated by "|"
    "geneSnippets"  # the phrases around the gene mentions, separated by "|"
    )

# fields of the output file
MutRec = namedtuple("mutation_desc", mutFields)

# long form -> one-letter conversion table for amino acids
threeToOne = \
    {'Cys': 'C', 'Asp': 'D', 'Ser': 'S', 'Gln': 'Q', 'Lys': 'K',
     'Ile': 'I', 'Pro': 'P', 'Thr': 'T', 'Phe': 'F', 'Asn': 'N',
     'Gly': 'G', 'His': 'H', 'Leu': 'L', 'Arg': 'R', 'Trp': 'W',
     'Ala': 'A', 'Val':'V',  'Glu': 'E', 'Tyr': 'Y', 'Met': 'M',
     'Sec': 'U',  # Sec = sometimes used as amino acid (same as Ter)
     'Ter': '*',   # the termination codon
     'Stop': '*',   # the termination codon
     'Alanine'       : 'A',
     'Aspartic acid' : 'B',
     'Asparagine'    : 'B',
     'Cysteine'      : 'C',
     'Aspartic Acid' : 'D',
     'Glutamic Acid' : 'E',
     'Phenylalanine' : 'F',
     'Glycine'       : 'G',
     'Histidine'     : 'H',
     'Isoleucine'    : 'I',
     'Lysine'        : 'K',
     'Leucine'       : 'L',
     'Methionine'    : 'M',
     'Asparagine'    : 'N',
     'Proline'       : 'P',
     'Glutamine'     : 'Q',
     'Arginine'      : 'R',
     'Serine'        : 'S',
     'Threonine'     : 'T',
     'Valine'        : 'V',
     'Tryptophan'    : 'W',
     'Any'           : 'X',
     'Tyrosine'      : 'Y',
     'Glutamine'     : 'Z',
     'Glutamic Acid' : 'Z'
     }

# same but lower case
threeToOneLower = dict([[k.lower(),v] for k,v in threeToOne.items()])
# one-letter -> three-letter conversion table for amino acids
oneToThree = \
    {'C':'Cys', 'D':'Asp', 'S':'Ser', 'Q':'Gln', 'K':'Lys',
     'I':'Ile', 'P':'Pro', 'T':'Thr', 'F':'Phe', 'N':'Asn',
     'G':'Gly', 'H':'His', 'L':'Leu', 'R':'Arg', 'W':'Trp',
     'A':'Ala', 'V':'Val', 'E':'Glu', 'Y':'Tyr', 'M':'Met',
     'U':'Sec', '*':'Stop','X':'Any'} 

# from amino acid to all possible codons
aaToDna = {
 'A': ['GCA', 'GCC', 'GCG', 'GCT'],
 'C': ['TGT', 'TGC'],
 'D': ['GAT', 'GAC'],
 'E': ['GAG', 'GAA'],
 'F': ['TTT', 'TTC'],
 'G': ['GGT', 'GGG', 'GGA', 'GGC'],
 'H': ['CAT', 'CAC'],
 'I': ['ATC', 'ATA', 'ATT'],
 'K': ['AAG', 'AAA'],
 'L': ['CTC', 'CTG', 'CTA', 'CTT', 'TTA', 'TTG'],
 'M': ['ATG'],
 'N': ['AAC', 'AAT'],
 'P': ['CCT', 'CCA', 'CCG', 'CCC'],
 'Q': ['CAG', 'CAA'],
 'R': ['AGG', 'AGA', 'CGA', 'CGC', 'CGG', 'CGT'],
 'S': ['AGC', 'AGT', 'TCG', 'TCA', 'TCC', 'TCT'],
 'T': ['ACC', 'ACA', 'ACG', 'ACT'],
 'V': ['GTA', 'GTC', 'GTG', 'GTT'],
 'W': ['TGG'],
 'Y': ['TAT', 'TAC'],
 '*': ['TAG', 'TAA', 'TGA']}

# the genetic code
dnaToAa = {
    'ATA':'I', 'ATC':'I', 'ATT':'I', 'ATG':'M',
    'ACA':'T', 'ACC':'T', 'ACG':'T', 'ACT':'T',
    'AAC':'N', 'AAT':'N', 'AAA':'K', 'AAG':'K',
    'AGC':'S', 'AGT':'S', 'AGA':'R', 'AGG':'R',
    'CTA':'L', 'CTC':'L', 'CTG':'L', 'CTT':'L', 
    'CTN':'L',
    'CCA':'P', 'CCC':'P', 'CCG':'P', 'CCT':'P',
    'CCN':'P',
    'CAC':'H', 'CAT':'H', 'CAA':'Q', 'CAG':'Q',
    'CGA':'R', 'CGC':'R', 'CGG':'R', 'CGT':'R',
    'CGN':'R',
    'GTA':'V', 'GTC':'V', 'GTG':'V', 'GTT':'V',
    'GTN':'V',
    'GCA':'A', 'GCC':'A', 'GCG':'A', 'GCT':'A',
    'GCN':'A',
    'GAC':'D', 'GAT':'D', 'GAA':'E', 'GAG':'E',
    'GGA':'G', 'GGC':'G', 'GGG':'G', 'GGT':'G',
    'GGN':'G',
    'TCA':'S', 'TCC':'S', 'TCG':'S', 'TCT':'S',
    'TCN':'S',
    'TTC':'F', 'TTT':'F', 'TTA':'L', 'TTG':'L',
    'TAC':'Y', 'TAT':'Y', 'TAA':'_', 'TAG':'_',
    'TGC':'C', 'TGT':'C', 'TGA':'_', 'TGG':'W',
    }

# will be filled later on with data, see below
#aaDnaMuts = {}

# these look like mutations but are definitely not mutations
# satellites?
blackList = [
    ("D", 11, "S"),
    ("D", 12, "S"),
    ("D", 13, "S"),
    ("D", 14, "S"),
    ("D", 15, "S"),
    ("D", 16, "S")]

# ==== FUNCTIONS =====

#def prepAaMutTable():
#    """ create a table (aa1, aa2) -> list of nucleotides that change and their positions
#    """
#    ret = {}
#    for aa1 in aaToDna:
#        for aa2 in aaToDna:
#            aaChangeToDnaChange(aa1, aa2)
#
#def indexPsls(fname):
#    psl = kent.psl.pslLoadAll(fname)
#    pslIdx = {}
#    while psl:
#        pslIdx[str(psl.contents.qName)] = psl
#        psl = psl.contents.next
#    # memory leak, struct behind p not freed
#    return pslIdx
    
#protMap = indexPsls("toRefseq/protMap/work/protToTrans.psl")


def indexGenes(upAnnots):
    """ given rows from annotation file, return extId, counts of uniprot accession and 
      dict with uniprot accession to list of annotations """
    upCounts = Counter()
    accToAnnots = defaultdict(list)
    assert(len(upAnnots)>0)
    extId = None
    for up in upAnnots:
        upCounts.update([up.uniProtAcc])
        accToAnnots[up.uniProtAcc].append(up)
        extId = up.externalId
    return extId, upCounts, accToAnnots

def findSeqs(seqs, accs, pos, res):
    " return all uniprot accessions from accs with at least one variant with residue at pos "
    matchSeqs = []
    for acc in accs:
        isoSeqs = seqs[acc]
        for seqId, seq in isoSeqs:
            if pos < len(seq) and seq[pos]==res:
                matchSeqs.append(seqId)
                break
    return matchSeqs

def parseRegex(mutDataDir):
    """ parse and compile regexes to list (seqType, mutType, patName, pat) """
    # read regexes, translate placeholders to long form and compile
    replDict = {
    "sep"         : r"""(?:^|[\s\(\[\'"/,\-])""",
    "fromPos"     : r'(?P<fromPos>[1-9][0-9]+)',
    "toPos"       : r'(?P<toPos>[1-9][0-9]+)',
    "pos"         : r'(?P<pos>[1-9][0-9]+)',
    "origAaShort" : r'(?P<origAaShort>[CISQMNPKDTFAGHLRWVEY])',
    "mutAaShort"  : r'(?P<mutAaShort>[CISQMNPKDTFAGHLRWVEY*])',
    "origAaLong"  : r'(?P<origAaLong>(CYS|ILE|SER|GLN|MET|ASN|PRO|LYS|ASP|THR|PHE|ALA|GLY|HIS|LEU|ARG|TRP|VAL|GLU|TYR|TER|GLUTAMINE|GLUTAMIC ACID|LEUCINE|VALINE|ISOLEUCINE|LYSINE|ALANINE|GLYCINE|ASPARTATE|METHIONINE|THREONINE|HISTIDINE|ASPARTIC ACID|ARGININE|ASPARAGINE|TRYPTOPHAN|PROLINE|PHENYLALANINE|CYSTEINE|SERINE|GLUTAMATE|TYROSINE|STOP))',
    "mutAaLong"  : r'(?P<mutAaLong>(CYS|ILE|SER|GLN|MET|ASN|PRO|LYS|ASP|THR|PHE|ALA|GLY|HIS|LEU|ARG|TRP|VAL|GLU|TYR|TER|GLUTAMINE|GLUTAMIC ACID|LEUCINE|VALINE|ISOLEUCINE|LYSINE|ALANINE|GLYCINE|ASPARTATE|METHIONINE|THREONINE|HISTIDINE|ASPARTIC ACID|ARGININE|ASPARAGINE|TRYPTOPHAN|PROLINE|PHENYLALANINE|CYSTEINE|SERINE|GLUTAMATE|TYROSINE|STOP))',
    "dna"         : r'(?P<dna>[actgACTG])',
    "origDna"     : r'(?P<origDna>[actgACTG])',
    "mutDna"      : r'(?P<mutDna>[actgACTG])',
    "fs"          : r'(?P<fs>(fs\*?[0-9]*)|fs\*|fs|)?',
    }
    regexTab = join(mutDataDir, "regex.txt")
    logging.info("Parsing regexes from %s" % regexTab)
    regexList = []
    counts = defaultdict(int)
    for row in maxCommon.iterTsvRows(regexTab):
        logging.debug("Translating %s" % row.pat)
        patName = row.patName
        if patName=="":
            patName = row.pat
        patFull = row.pat.format(**replDict)
        logging.debug("full pattern is %s" % patFull)
        flags = 0
        if "Long}" in row.pat:
            flags = re.IGNORECASE
            logging.debug("ignoring case for this pattern")
        patComp = re.compile(patFull, flags=flags)
        regexList.append((row.seqType, row.mutType, patName, patComp))
        counts[(row.seqType, row.mutType)] += 1

    for regexType, count in counts.iteritems():
            logging.info("regexType %s, Found %d regexes" % (str(regexType), count))
    return regexList

class SeqData(object):
    """ functions to get sequences and map between identifiers for entrez genes,
    uniprot, refseq, etc """

    def __init__(self, mutDataDir, taxId):
        " open db files, compile patterns, parse input as far as possible "
        if mutDataDir==None:
            return
        # load uniprot into mem
        logging.info("Reading data")
        fname = join(mutDataDir, "uniprot.tab.marshal")
        logging.debug("Reading uniprot data from %s" % fname)
        data = marshal.load(open(fname))
        self.entrez2Up = data[taxId]["entrezToUp"]
        self.upSeqs = data[taxId]["upSeqs"]
        self.upToSym = data[taxId]["upToSym"]

        # load entrez -> refseq/refprot/symbol
        fname = join(mutDataDir, "entrezToRefseq.%s.tab.marshal" % taxId)
        logging.debug("Reading entrez data from %s" % fname)
        entrezRefseq = marshal.load(open(fname))
        self.entrez2refseqs = entrezRefseq["entrez2refseqs"]
        self.entrez2refprots = entrezRefseq["entrez2refprots"]
        self.entrez2sym = entrezRefseq["entrez2sym"]

        # pmid -> entrez genes
        fname = join(mutDataDir, "pmid2entrez.dbm")
        logging.info("opening %s" % fname)
        pmid2entrez = gdbm.open(fname, "r")
        self.pmid2entrez = pmid2entrez
        
        # refseq sequences
        fname = join(mutDataDir, "refGeneSeqs.dbm")
        logging.info("opening %s" % fname)
        seqs = gdbm.open(fname, "r")
        self.seqs = seqs
        
        # refprot to refseqId
        # refseq to CDS Start
        fname = join(mutDataDir, "refseqInfo.tab")
        logging.debug("Reading %s" % fname)
        self.refProtToRefSeq = {}
        self.refSeqCds = {}
        for row in maxCommon.iterTsvRows(fname):
            self.refProtToRefSeq[row.refProt] = row.refSeq
            #if not "," in row.cdsStart:
            self.refSeqCds[row.refSeq] = int(row.cdsStart)-1
        self.seqCache = {}

        # refseq to genome
        liftFname = join(mutDataDir, "refGene.%s.psl.dbm" % taxId)
        logging.debug("Opening %s" % liftFname)
        self.refGenePsls = gdbm.open(liftFname, "r")
        #self.protMap = pslMapBed.indexPsls(liftFname)
        self.refGenePslCache = {}

        logging.info("Reading of data finished")

    def getSeq(self, seqId):
        " get seq from db , cache results "
        seqId = str(seqId) # gdbm doesn't like unicode
        if seqId not in self.seqCache:
            comprSeq = self.seqs[seqId]
            seq = zlib.decompress(comprSeq)
            self.seqCache[seqId] = seq
        else:
            seq = self.seqCache[seqId]
        return seq

    def entrezToUniProt(self, entrezGene):
        return self.entrez2Up.get(entrezGene, None)

    def entrezToOtherDb(self, entrezGene, db):
        " return accession in otherDb for entrezGene "
        if db=="refseq":
            return self.entrezToRefseqProts(entrezGene)
        elif db=="uniprot":
            return self.entrezToUniProt(entrezGene)
        else:
            assert(False)
        assert(False)

    def entrezToSym(self, entrezGene):
        entrezGene = int(entrezGene)
        if entrezGene in self.entrez2sym:
            geneSym = self.entrez2sym[entrezGene]
            logging.debug("Entrez gene %s = symbol %s" % (entrezGene, geneSym))
            return geneSym
        else:
            return None

    def entrezToRefseqProts(self, entrezGene):
        " map entrez gene to refseq prots like NP_xxx "
        if entrezGene not in self.entrez2refprots:
            logging.debug("gene %d is not valid or not in selected species" % entrezGene)
            return []
        protIds = self.entrez2refprots[entrezGene]
        logging.debug("Entrez gene %s is mapped to proteins %s" % \
            (entrezGene, ",".join(protIds)))
        return protIds

    def getCdsStart(self, refseqId):
        cdsStart = self.refSeqCds[refseqId]
        return cdsStart

    def getEntrezGenes(self, pmid):
        if not pmid in self.pmid2entrez:
            return None
        dbRes = self.pmid2entrez[pmid]
        entrezGenes = dbRes.split(",")
        entrezGenes = [int(x) for x in entrezGenes]
        return entrezGenes

    def getRefSeqId(self, refProtId):
        return self.refProtToRefSeq[refProtId]

    def getRefseqPsls(self, refseqId):
        """ return psl objects for regseq Id
            as Gb doesn't support version numbers, stripping those 
        """
        logging.debug("Getting mapping psl for %s" % refseqId)
        refseqId = str(refseqId.split(".")[0])
        if refseqId in self.refGenePslCache:
            psls = self.refGenePslCache[refseqId]
        else:
            #print repr(refseqId)
            #print self.refGenePsls[str('NM_000527.4')]
            pslLines = self.refGenePsls[refseqId]
            psls = []
            for line in pslLines.split("\n"):
                psl = Psl(line.split("\t"))
                psls.append(psl)
            self.refGenePslCache[refseqId] = psls
        return psls

    def makeStub(self):
        self.seqCache = {
        "NP_000518.1": "MGPWGWKLRWTVALLLAAAGTAVGDRCERNEFQCQDGKCISYKWVCDGSAECQDGSDESQETCLSVTCKSGDFSCGGRVNRCIPQFWRCDGQVDCDNGSDEQGCPPKTCSQDEFRCHDGKCISRQFVCDSDRDCLDGSDEASCPVLTCGPASFQCNSSTCIPQLWACDNDPDCEDGSDEWPQRCRGLYVFQGDSSPCSAFEFHCLSGECIHSSWRCDGGPDCKDKSDEENCAVATCRPDEFQCSDGNCIHGSRQCDREYDCKDMSDEVGCVNVTLCEGPNKFKCHSGECITLDKVCNMARDCRDWSDEPIKECGTNECLDNNGGCSHVCNDLKIGYECLCPDGFQLVAQRRCEDIDECQDPDTCSQLCVNLEGGYKCQCEEGFQLDPHTKACKAVGSIAYLFFTNRHEVRKMTLDRSEYTSLIPNLRNVVALDTEVASNRIYWSDLSQRMICSTQLDRAHGVSSYDTVISRDIQAPDGLAVDWIHSNIYWTDSVLGTVSVADTKGVKRKTLFRENGSKPRAIVVDPVHGFMYWTDWGTPAKIKKGGLNGVDIYSLVTENIQWPNGITLDLLSGRLYWVDSKLHSISSIDVNGGNRKTILEDEKRLAHPFSLAVFEDKVFWTDIINEAIFSANRLTGSDVNLLAENLLSPEDMVLFHNLTQPRGVNWCERTTLSNGGCQYLCLPAPQINPHSPKFTCACPDGMLLARDMRSCLTEAEAAVATQETSTVRLKVSSTAVRTQHTTTRPVPDTSRLPGATPGLTTVEIVTMSHQALGDVAGRGNEKKPSSVRALSIVLPIVLLVFLCLGVFLLWKNWRLKNINSINFDNPVYQKTTEDEVHICHNQDGYSYPSRQMVSLEDDVA",
        "NM_000527.4":"CTCTTGCAGTGAGGTGAAGACATTTGAAAATCACCCCACTGCAAACTCCTCCCCCTGCTAGAAACCTCACATTGAAATGCTGTAAATGACGTGGGCCCCGAGTGCAATCGCGGGAAGCCAGGGTTTCCAGCTAGGACACAGCAGGTCGTGATCCGGGTCGGGACACTGCCTGGCAGAGGCTGCGAGCATGGGGCCCTGGGGCTGGAAATTGCGCTGGACCGTCGCCTTGCTCCTCGCCGCGGCGGGGACTGCAGTGGGCGACAGATGCGAAAGAAACGAGTTCCAGTGCCAAGACGGGAAATGCATCTCCTACAAGTGGGTCTGCGATGGCAGCGCTGAGTGCCAGGATGGCTCTGATGAGTCCCAGGAGACGTGCTTGTCTGTCACCTGCAAATCCGGGGACTTCAGCTGTGGGGGCCGTGTCAACCGCTGCATTCCTCAGTTCTGGAGGTGCGATGGCCAAGTGGACTGCGACAACGGCTCAGACGAGCAAGGCTGTCCCCCCAAGACGTGCTCCCAGGACGAGTTTCGCTGCCACGATGGGAAGTGCATCTCTCGGCAGTTCGTCTGTGACTCAGACCGGGACTGCTTGGACGGCTCAGACGAGGCCTCCTGCCCGGTGCTCACCTGTGGTCCCGCCAGCTTCCAGTGCAACAGCTCCACCTGCATCCCCCAGCTGTGGGCCTGCGACAACGACCCCGACTGCGAAGATGGCTCGGATGAGTGGCCGCAGCGCTGTAGGGGTCTTTACGTGTTCCAAGGGGACAGTAGCCCCTGCTCGGCCTTCGAGTTCCACTGCCTAAGTGGCGAGTGCATCCACTCCAGCTGGCGCTGTGATGGTGGCCCCGACTGCAAGGACAAATCTGACGAGGAAAACTGCGCTGTGGCCACCTGTCGCCCTGACGAATTCCAGTGCTCTGATGGAAACTGCATCCATGGCAGCCGGCAGTGTGACCGGGAATATGACTGCAAGGACATGAGCGATGAAGTTGGCTGCGTTAATGTGACACTCTGCGAGGGACCCAACAAGTTCAAGTGTCACAGCGGCGAATGCATCACCCTGGACAAAGTCTGCAACATGGCTAGAGACTGCCGGGACTGGTCAGATGAACCCATCAAAGAGTGCGGGACCAACGAATGCTTGGACAACAACGGCGGCTGTTCCCACGTCTGCAATGACCTTAAGATCGGCTACGAGTGCCTGTGCCCCGACGGCTTCCAGCTGGTGGCCCAGCGAAGATGCGAAGATATCGATGAGTGTCAGGATCCCGACACCTGCAGCCAGCTCTGCGTGAACCTGGAGGGTGGCTACAAGTGCCAGTGTGAGGAAGGCTTCCAGCTGGACCCCCACACGAAGGCCTGCAAGGCTGTGGGCTCCATCGCCTACCTCTTCTTCACCAACCGGCACGAGGTCAGGAAGATGACGCTGGACCGGAGCGAGTACACCAGCCTCATCCCCAACCTGAGGAACGTGGTCGCTCTGGACACGGAGGTGGCCAGCAATAGAATCTACTGGTCTGACCTGTCCCAGAGAATGATCTGCAGCACCCAGCTTGACAGAGCCCACGGCGTCTCTTCCTATGACACCGTCATCAGCAGAGACATCCAGGCCCCCGACGGGCTGGCTGTGGACTGGATCCACAGCAACATCTACTGGACCGACTCTGTCCTGGGCACTGTCTCTGTTGCGGATACCAAGGGCGTGAAGAGGAAAACGTTATTCAGGGAGAACGGCTCCAAGCCAAGGGCCATCGTGGTGGATCCTGTTCATGGCTTCATGTACTGGACTGACTGGGGAACTCCCGCCAAGATCAAGAAAGGGGGCCTGAATGGTGTGGACATCTACTCGCTGGTGACTGAAAACATTCAGTGGCCCAATGGCATCACCCTAGATCTCCTCAGTGGCCGCCTCTACTGGGTTGACTCCAAACTTCACTCCATCTCAAGCATCGATGTCAACGGGGGCAACCGGAAGACCATCTTGGAGGATGAAAAGAGGCTGGCCCACCCCTTCTCCTTGGCCGTCTTTGAGGACAAAGTATTTTGGACAGATATCATCAACGAAGCCATTTTCAGTGCCAACCGCCTCACAGGTTCCGATGTCAACTTGTTGGCTGAAAACCTACTGTCCCCAGAGGATATGGTTCTCTTCCACAACCTCACCCAGCCAAGAGGAGTGAACTGGTGTGAGAGGACCACCCTGAGCAATGGCGGCTGCCAGTATCTGTGCCTCCCTGCCCCGCAGATCAACCCCCACTCGCCCAAGTTTACCTGCGCCTGCCCGGACGGCATGCTGCTGGCCAGGGACATGAGGAGCTGCCTCACAGAGGCTGAGGCTGCAGTGGCCACCCAGGAGACATCCACCGTCAGGCTAAAGGTCAGCTCCACAGCCGTAAGGACACAGCACACAACCACCCGACCTGTTCCCGACACCTCCCGGCTGCCTGGGGCCACCCCTGGGCTCACCACGGTGGAGATAGTGACAATGTCTCACCAAGCTCTGGGCGACGTTGCTGGCAGAGGAAATGAGAAGAAGCCCAGTAGCGTGAGGGCTCTGTCCATTGTCCTCCCCATCGTGCTCCTCGTCTTCCTTTGCCTGGGGGTCTTCCTTCTATGGAAGAACTGGCGGCTTAAGAACATCAACAGCATCAACTTTGACAACCCCGTCTATCAGAAGACCACAGAGGATGAGGTCCACATTTGCCACAACCAGGACGGCTACAGCTACCCCTCGAGACAGATGGTCAGTCTGGAGGATGACGTGGCGTGAACATCTGCCTGGAGTCCCGTCCCTGCCCAGAACCCTTCCTGAGACCTCGCCGGCCTTGTTTTATTCAAAGACAGAGAAGACCAAAGCATTGCCTGCCAGAGCTTTGTTTTATATATTTATTCATCTGGGAGGCAGAACAGGCTTCGGACAGTGCCCATGCAATGGCTTGGGTTGGGATTTTGGTTTCTTCCTTTCCTCGTGAAGGATAAGAGAAACAGGCCCGGGGGGACCAGGATGACACCTCCATTTCTCTCCAGGAAGTTTTGAGTTTCTCTCCACCGTGACACAATCCTCAAACATGGAAGATGAAAGGGGAGGGGATGTCAGGCCCAGAGAAGCAAGTGGCTTTCAACACACAACAGCAGATGGCACCAACGGGACCCCCTGGCCCTGCCTCATCCACCAATCTCTAAGCCAAACCCCTAAACTCAGGAGTCAACGTGTTTACCTCTTCTATGCAAGCCTTGCTAGACAGCCAGGTTAGCCTTTGCCCTGTCACCCCCGAATCATGACCCACCCAGTGTCTTTCGAGGTGGGTTTGTACCTTCCTTAAGCCAGGAAAGGGATTCATGGCGTCGGAAATGATCTGGCTGAATCCGTGGTGGCACCGAGACCAAACTCATTCACCAAATGATGCCACTTCCCAGAGGCAGAGCCTGAGTCACTGGTCACCCTTAATATTTATTAAGTGCCTGAGACACCCGGTTACCTTGGCCGTGAGGACACGTGGCCTGCACCCAGGTGTGGCTGTCAGGACACCAGCCTGGTGCCCATCCTCCCGACCCCTACCCACTTCCATTCCCGTGGTCTCCTTGCACTTTCTCAGTTCAGAGTTGTACACTGTGTACATTTGGCATTTGTGTTATTATTTTGCACTGTTTTCTGTCGTGTGTGTTGGGATGGGATCCCAGGCCAGGGAAAGCCCGTGTCAATGAATGCCGGGGACAGAGAGGGGCAGGTTGACCGGGACTTCAAAGCCGTGATCGTGAATATCGAGAACTGCCATTGTCGTCTTTATGTCCGCCCACCTAGTGCTTCCACTTCTATGCAAATGCCTCCAAGCCATTCACTTCCCCAATCTTGTCGTTGATGGGTATGTGTTTAAAACATGCACGGTGAGGCCGGGCGCAGTGGCTCACGCCTGTAATCCCAGCACTTTGGGAGGCCGAGGCGGGTGGATCATGAGGTCAGGAGATCGAGACCATCCTGGCTAACACGTGAAACCCCGTCTCTACTAAAAATACAAAAAATTAGCCGGGCGTGGTGGCGGGCACCTGTAGTCCCAGCTACTCGGGAGGCTGAGGCAGGAGAATGGTGTGAACCCGGGAAGCGGAGCTTGCAGTGAGCCGAGATTGCGCCACTGCAGTCCGCAGTCTGGCCTGGGCGACAGAGCGAGACTCCGTCTCAAAAAAAAAAAACAAAAAAAAACCATGCATGGTGCATCAGCAGCCCATGGCCTCTGGCCAGGCATGGCGAGGCTGAGGTGGGAGGATGGTTTGAGCTCAGGCATTTGAGGCTGTCGTGAGCTATGATTATGCCACTGCTTTCCAGCCTGGGCAACATAGTAAGACCCCATCTCTTAAAAAATGAATTTGGCCAGACACAGGTGCCTCACGCCTGTAATCCCAGCACTTTGGGAGGCTGAGCTGGATCACTTGAGTTCAGGAGTTGGAGACCAGGCCTGAGCAACAAAGCGAGATCCCATCTCTACAAAAACCAAAAAGTTAAAAATCAGCTGGGTACGGTGGCACGTGCCTGTGATCCCAGCTACTTGGGAGGCTGAGGCAGGAGGATCGCCTGAGCCCAGGAGGTGGAGGTTGCAGTGAGCCATGATCGAGCCACTGCACTCCAGCCTGGGCAACAGATGAAGACCCTATTTCAGAAATACAACTATAAAAAAATAAATAAATCCTCCAGTCTGGATCGTTTGACGGGACTTCAGGTTCTTTCTGAAATCGCCGTGTTACTGTTGCACTGATGTCCGGAGAGACAGTGACAGCCTCCGTCAGACTCCCGCGTGAAGATGTCACAAGGGATTGGCAATTGTCCCCAGGGACAAAACACTGTGTCCCCCCCAGTGCAGGGAACCGTGATAAGCCTTTCTGGTTTCGGAGCACGTAAATGCGTCCCTGTACAGATAGTGGGGATTTTTTGTTATGTTTGCACTTTGTATATTGGTTGAAACTGTTATCACTTATATATATATATATACACACATATATATAAAATCTATTTATTTTTGCAAACCCTGGTTGCTGTATTTGTTCAGTGACTATTCTCGGGGCCCTGTGTAGGGGGTTATTGCCTCTGAAATGCCTCTTCTTTATGTACAAAGATTATTTGCACGAACTGGACTGTGTGCAACGCTTTTTGGGAGAATGATGTCCCCGTTGTATGTATGAGTGGCTTCTGGGAGATGGGTGTCACTTTTTAAACCACTGTATAGAAGGTTTTTGTAGCCTGAATGTCTTACTGTGATCAATTAAATTTCTTAAATGAACCAATTTGTCTAAAAAAAAAAA"
        }
        self.refSeqCds["NM_000527.4"] = 187

Mention = namedtuple("Mention", "patName,start,end")

class MappedVariant(object):
    """ A mapped variant is a type-range-sequence combination from a text, 
        located on one or multiple sequences 
    """
    __slots__=VariantFields

    def __init__(self, mutType, seqType, start, end, orig, mut, seqId=""):
        self.mutType = mutType
        self.seqType = seqType
        self.seqId = seqId
        self.geneId = ""
        self.start = int(start)
        self.end = int(end)
        self.origSeq = orig
        self.mutSeq = mut

    def posDesc(self):
        """ 
        return a string that describes this variant without any mapping information"
        """
        return "%s-%d-%s" % (self.origSeq, self.start, self.mutSeq)

    def asRow(self):
        row =[]
        for i in self.__slots__:
            row.append(str(getattr(self, i)))
        return row
        
    def copyNoLocs(self):
        #" return copy of myself without any seqIdLocs "
        #newObj = MappedVariant(self.mutType, self.seqType, self.start, self.end, self.origSeq, self.mutSeq)
        #return newObj
        pass

    def __repr__(self):
        return ",".join(self.asRow())
    
def parseMatch(match, patName):
    groups = match.groupdict()
    # grab long and short versions of amino acid
    if "origAaShort" in groups:
        origSeq = groups["origAaShort"]
        seqType = "aa"
    if "origAaLong" in groups:
        origSeq = threeToOneLower[groups["origAaLong"].lower()]
        seqType = "aa"
    if "mutAaShort" in groups:
        mutSeq = groups["mutAaShort"]
        seqType = "aa"
    if "mutAaLong" in groups:
        mutSeq = threeToOneLower[groups["mutAaLong"].lower()]
        seqType = "aa"
    if "origDna" in groups:
        origSeq = groups["origDna"]
        seqType = "dna"
    if "mutDna" in groups:
        mutSeq = groups["mutDna"]
        seqType = "dna"
    mutSeq = mutSeq.upper()
    origSeq = origSeq.upper()

    if "fromPos" in groups:
        protStart = int(groups["fromPos"])-1
    if "toPos" in groups:
        protEnd = int(groups["toPos"])-1
    else:
        pos = int(groups["pos"])-1
        protStart = pos
        protEnd = pos+1

    var = MappedVariant("sub", seqType, protStart, protEnd, origSeq, mutSeq)

    start = match.start()
    end = match.end()
    mention = Mention(patName, start, end)

    if (origSeq, protStart, mutSeq) in blackList:
        logging.debug("Variant %s,%d,%s is blacklisted" % (origSeq, protStart, mutSeq))
        return None, None
    else:
        return var, mention

def findGenes(pmid, abstract, title, text):
    """ return dict where [entrez|title|abstract|text] = list of gene mentions 
    """
    geneTypes = {}
    entrezGenes = geneData.getEntrezGenes(pmid)
    if entrezGenes!=None:
        geneTypes["entrez"] = entrezGenes
    return geneTypes

def findVariants(regexes, text):
    """ put mutation mentions from document together into dicts indexed by normal form 
        return list (variant, list of mentions)
    """
    varMentions = defaultdict(list)
    varDescObj = {}
    for seqType, mutType, patName, pat in regexes:
        if mutType=="sub":
            for match in pat.finditer(text):
                logging.debug("Match: Pattern %s, text %s" % (patName, match.groups()))
                variant, mention = parseMatch(match, patName)
                if variant!=None:
                    varDescObj[variant.posDesc()] = variant
                    varMentions[variant.posDesc()].append(mention)
                    debugSnip = pubAlg.getSnippet(text, mention.start, mention.end, maxContext=60)
                    logging.debug("Found Variant: %s, snippet %s" % (str(variant), debugSnip))

    # convert to list of (variant, mentions)
    variants = []
    for varDesc, mentions in varMentions.iteritems():
        varObj = varDescObj[varDesc]
        variants.append((varObj, mentions))
    return variants
    
def makeHgvsStr(seqType, seqId, origSeq, pos, mutSeq):
    if seqType=="p":
        desc = "%s:p.%s%d%s" % (seqId, oneToThree[origSeq], pos+1, oneToThree[mutSeq])
    elif seqType=="c":
        desc = "%s:c.%d%s>%s" % (seqId, pos+1, origSeq, mutSeq)
    elif seqType=="r":
        desc = "%s:r.%d%s>%s" % (seqId, pos+1, origSeq, mutSeq)
    return desc
  
def makeHgvsSub(hgvsType, variants):
   " create |-sep HGVS stringlist for all seqIds and a mutation"
   #logging.debug("Creating HGVS type %s for vars %s" % (hgvsType, variants))
   ret = []
   for protVar in variants:
       hgvsStr = makeHgvsStr(hgvsType, protVar.seqId, protVar.origSeq, protVar.start, protVar.mutSeq)
       ret.append(hgvsStr)
   return "|".join(ret)

def firstDiffNucl(str1, str2):
    """Return pos and letters where strings differ. Returns None if more than one diff char"""
    assert(len(str1)==len(str2))
    if str1==str2:
        return None
    diffs = 0
    i = 0
    for ch1, ch2 in zip(str1, str2):
        if ch1 != ch2:
            diffs += 1
            diffCh1 = ch1
            diffCh2 = ch2
            diffPos = i
        i+=1
    if diffs>1 or diffs==0:
        return None
    else:
        return (diffPos, diffCh1, diffCh2)

def possibleDnaChanges(origAa, mutAa, origDna):
    """ figure out which nucleotides were possibly mutated by an amino acid change 
    will only look for single-bp mutations
    returns list of: position of nucleic acid, original and new basepair
    >>> possibleDnaChanges("V", "V", "GTA")
    [(2, 'A', 'T'), (2, 'A', 'C'), (2, 'A', 'G')]
    >>> possibleDnaChanges("V", "I", "GTA")
    [(0, 'G', 'A')]
    >>> possibleDnaChanges("G", "G", "GGC")
    [(2, 'C', 'T'), (2, 'C', 'G'), (2, 'C', 'A')]
    """
    origDna = origDna.upper()
    ret = set()
    mutDnas = backTrans(mutAa)
    logging.debug("Looking for possible DNA change. Aa change %s -> %s, original dna %s" % (origAa, mutAa, origDna))
    for mutDna in mutDnas:
        diffTuple = firstDiffNucl(origDna, mutDna)
        if diffTuple!=None:
            ret.add( diffTuple )
            logging.debug("found possible mutated DNA: %s" % (mutDna))
    return list(ret)

#def bedToPsl(chrom, chromSize, start, end, name):
    #qSize = end-start
    #psl = kent.psl.pslNew(name, qSize, 0, qSize, chrom, chromSize, start, end, "+", 1, 0)
    #psl.contents.match = qSize
    #psl.contents.qStarts[0]=0
    #psl.contents.tStarts[0]=start
    #psl.contents.blockSizes[0]=(end-start)
    #psl.contents.blockCount=1
    #kent.psl.pslWriteAll(psl, "temp.psl", 0)
    #return psl
    
def backTrans(aa):
    """ back translate protein to all nucleotide strings 
    Returns the back-translated nucleotide sequences for a protein and codon 
    table combination.
    copied from http://www.biostars.org/p/3129/
    >>> protein = 'FVC'
    >>> len(backTrans(protein))
    16
    >>> backTrans('CD')
    ['TGTGAT', 'TGCGAT', 'TGTGAC', 'TGCGAC']
    """
    # create initial sequences == list of codons for the first amino acid
    sequences = [codon for codon in aaToDna[aa[0]]]
    for amino_acid in aa[1:]:
        # add each codon to each existing sequence replacing sequences
        # leaves (num_codons * num_sequences) for next amino acid 
        to_extend = sequences
        sequences = []
        for codon in aaToDna[amino_acid]:
            for sequence in to_extend:
                sequence += codon
                sequences.append(sequence)
    return sequences

def translate(dna):
    " return the aa translation of a dna seq "
    aaSeq = []
    for i in range(0, len(dna), 3):
        codon = dna[i:i+3].upper()
        aa = dnaToAa[codon]
        aaSeq.append(aa)
    return "".join(aaSeq)

def dnaAtCodingPos(refseqId, start, end, expectAa):
    """ 
    get nucleotide at CODING position in refseqId, check against expected aa
    also return positions on cdna
    """
    logging.debug("Checking if codons from %d-%d in %s correspond to %s" % 
        (start, end, refseqId, expectAa))
    cdsStart    = geneData.getCdsStart(str(refseqId))
    nuclStart   = cdsStart + (3*start)
    nuclEnd     = nuclStart + 3*(end-start)
    cdnaSeq     = geneData.getSeq(refseqId)
    nuclSeq     = cdnaSeq[nuclStart:nuclEnd]
    foundAa     = translate(nuclSeq)
    logging.debug("CDS start is %d, nucl pos is %d, codon is %s" % (cdsStart, nuclStart, nuclSeq))
    assert(foundAa==expectAa)
    return nuclSeq, nuclStart, nuclEnd


def mapToCodingAndRna(protVars):
    """ given ref protein positions and refseq proteinIds, try to figure out the nucleotide 
    changes on the refseq cdna sequence and add these to the variant object
    """
    codVars = []
    rnaVars  = []
    for protVar in protVars:
        transId     = geneData.getRefSeqId(protVar.seqId)
        pos         = protVar.start
        origDnaSeq, cdnaStart, cdnaEnd  = dnaAtCodingPos(transId, pos, pos+len(protVar.origSeq), protVar.origSeq)
        possChanges = possibleDnaChanges(protVar.origSeq, protVar.mutSeq, origDnaSeq)
        for relPos, oldNucl, newNucl in possChanges:
            cdStart = 3 * protVar.start + relPos
            cdEnd   = cdStart+len(origDnaSeq)
            codVar = MappedVariant(protVar.mutType, "dna", cdStart, cdEnd, oldNucl, newNucl, transId)
            codVars.append(codVar)

            rnaVar = MappedVariant(protVar.mutType, "dna", cdnaStart, cdnaEnd, oldNucl, newNucl, transId)
            rnaVars.append(rnaVar)
            #hgvsStr = makeHgvsStr("c", transId, oldNucl, nuclPos, newNucl)
            #ret.append(hgvsStr)
    #return "|".join(ret)
    return codVars, rnaVars

class SeqVariant(object):
    " a variant grounded on a sequence, with pieces from the text "
    __slots__ = mutFields

    def __init__(self, varId, protVars, codVars, rnaVars, entrezGene, geneSym, mentions, text):
        self.varId   = varId
        self.patType = "sub"
        self.seqType = "prot"
        self.chrom      = ""
        self.start      = ""
        self.end        = ""
        self.geneSymbol = geneSym
        self.entrezId   = entrezGene
        self.hgvsProt   = makeHgvsSub("p", protVars)
        self.hgvsCoding = makeHgvsSub("c", codVars)
        self.hgvsRna    = makeHgvsSub("r", rnaVars)
        self.protId     = ""
        self.geneType   = "entrez"
        self.geneStarts = ""
        self.geneEnds   = ""
        self.geneSnippets = ""

        mutStarts = []
        mutEnds = []
        snippets = []
        patNames = []
        texts = []
        for m in mentions:
            mutStarts.append(str(m.start))
            mutEnds.append(str(m.end))
            snippets.append(pubAlg.getSnippet(text, m.start, m.end).replace("|"," "))
            patNames.append(m.patName)
            texts.append(text[m.start:m.end].strip("() -;,."))

        self.mutStarts = ",".join(mutStarts)
        self.mutEnds   = ",".join(mutEnds)
        self.mutPatNames= "|".join(patNames)
        self.mutSnippets = "|".join(snippets)
        self.texts = "|".join(texts)

    def asRow(self):
        row =[]
        for i in self.__slots__:
            row.append(str(getattr(self, i)))
        return row
        
    def __repr__(self):
        return ",".join(self.asRow())
        
def ungroundedMutsToFakeSeqVariants(ungroundedMuts, text):
    """ convert mutations that could not be grounded to "fake" variants
        that not located on any sequence but are easy to write to a file
    """
    muts = []
    for mut, mentions in ungroundedMuts:
        muts.append(SeqVariant("", [], [], [], "", "", mentions, text))
    return muts

def isSeqCorrect(protId, variant):
    " check if wild type sequence in protein corresponds to mutation positions "
    protStart = variant.start # uniprot is 1-based, we are 0-based
    protEnd   = variant.end 
    seq = geneData.getSeq(protId)

    if not protEnd<=len(seq):
        logging.debug("sequence %s is too short" % protId)
        return False
    
    aaSeq = seq[protStart:protEnd]
    if aaSeq==variant.origSeq:
        logging.debug("Seq match: Found %s at pos %d-%d in seq %s" % \
            (aaSeq, protStart, protEnd, protId))
        return True
    else:
        logging.debug("No seq match: Need %s, but found %s at pos %d-%d in seq %s" % \
            (variant.origSeq, aaSeq, protStart, protEnd, protId))
        return False

def entrezToUniProt(entrezGene):
    #geneSym = geneData["upToSym"][protId]
    #seq = geneData["upSeqs"][protId]
    pass


def hasSeqAtPos(protIds, mut):
    " check a list of protein IDs return those with a wild-type sequence at a position "
    if protIds==None:
        return []
    # try all protein seqs
    foundProtIds = []
    for protId in protIds:
        if isSeqCorrect(protId, mut):
            foundProtIds.append(protId)
    return foundProtIds

def tryProteinDbs(mut, entrezGene):
    " try various protein databases if they have matches for the wildtype aa at the right position "
    logging.debug("Trying entrez gene %s" % entrezGene)
    #for db in ["refseq", "oldRefseq", "uniprot"]:
    for db in ["refseq"]:
        protIds = geneData.entrezToOtherDb(entrezGene, db)
        foundProtIds = hasSeqAtPos(protIds, mut)
        if len(foundProtIds)!=0:
            return db, foundProtIds
    return None, []

def rewriteToRefProt(variant, protIds):
    " don't to any mapping, just create MappedVariants, one for each protein Id "
    varList = []
    for protId in protIds:
        varNew = copy.copy(variant)
        varNew.seqId = protId
        varList.append(varNew)
    return varList

def mapToRefProt(db, variant, protIds):
    " map protein position from some DB to all possible refprots"
    seqIdLocs = []
    for protId in protIds:
        psl = geneData.getProtMapPsl(protId)
        newPos = mapPos(psl, variant.start)
        seqIdLocs.append((protId, newPos))
    return seqIdLocs
        
def mapToGenome(rnaVars, bedName):
    " map to genome, remove duplicate results"
    logging.debug("Mapping rnaVars %s to genome" % rnaVars)
    maker = pslMapBed.PslMapBedMaker()
    beds = []
    doneBeds = set()
    for rnaVar in rnaVars:
        maker.clear()
        # get psl
        pslList = geneData.getRefseqPsls(rnaVar.seqId)
        assert(len(pslList)==1)
        mapPsl = pslList[0]
        maker.mapQuery(mapPsl, rnaVar.start, rnaVar.end)
        bed = maker.getBed(name=bedName)
        if bed not in doneBeds:
            beds.append(bed)
        doneBeds.add(bed)
        logging.debug("Got bed: %s" % str(bed))
    return beds
    
def groundMutations(docId, text, mutations, genes):
    """ ground mutations onto genes and return """
    groundedMuts = []
    ungroundedMuts = []

    varCount=1
    allBeds = []
    for variant, mentions in mutations:
        logging.debug("Grounding mutation %s onto genes %s" % (variant, genes))
        # try all entrez genes in article
        for entrezGene in genes:
            geneSym = geneData.entrezToSym(entrezGene)
            if not geneSym:
                logging.warn("No symbol for entrez gene %s ??" % str(entrezGene))
                continue
            db, protIds = tryProteinDbs(variant, entrezGene)
            if len(protIds)==0:
                ungroundedMuts.append((variant,  mentions))
            else:
                if db=="refseq":
                    protVars = rewriteToRefProt(variant, protIds)
                else:
                    protVars = mapToRefProt(variant, protIds)

                # create dna variants on various levels
                varId             = str(docId)+"_"+str(varCount)
                codVars, rnaVars  = mapToCodingAndRna(protVars)
                beds = mapToGenome(rnaVars, varId)

                groundedMuts.append(SeqVariant(varId, protVars, codVars, rnaVars, entrezGene, \
                    geneSym, mentions, text))
                allBeds.extend(beds)
            varCount += 1

    ungroundedMuts = ungroundedMutsToFakeSeqVariants(ungroundedMuts, text)
    return groundedMuts, ungroundedMuts, allBeds

def writeHeaders(outFh):
    prefixHeaders = ["docId", "isConfirmed"]
    outFh.write("\t".join(prefixHeaders)+"\t"+"\t".join(mutFields)+"\n")

def readFile(inFname):
    logging.info("Reading file %s" % inFname)
    text = open(inFname).read()
    title = ""
    abstract = ""
    pmid  = splitext(basename(inFname))[0]
    return pmid, title, abstract, text

def findInLocalFile(inFname, writer, regexes):
    pmid, title, abstract, text = readFile(inFname)
    variants  = findVariants(regexes, text)
    genes = findGenes(pmid, title, abstract, text)
    if not "entrez" in genes:
        logging.info("No genes for %s" % inFname)
        genes = []
        groundedMuts = []
        ungroundMuts = ungroundedMutsToFakeSeqVariants(variants, text)
        beds = []
    else:
        genes = genes["entrez"]
        groundedMuts, ungroundMuts, beds = groundMutations(pmid, text, variants, genes)
        # XX currently do not run if there is not entrez gene data
        writer.writeMuts(pmid, "confirmed", groundedMuts)
        writer.writeMuts(pmid, "notConfirmed", ungroundMuts)
        writer.writeBeds(beds)

def findInLocalDir(inDir, writer, regexes):
    for fname in glob.glob(join(inDir, "*.txt")):
        logging.info(fname)
        findInLocalFile(fname, writer, regexes)

class OutputWriter(object):
    def __init__(self, outFname, benchFname=None):
        self.outFh = maxTables.openFile(outFname, "w")
        self.bedFh = maxTables.openFile(outFname+".bed", "w")
        writeHeaders(self.outFh)

        # benchmarking stuff
        self.docCount = 0
        self.mutCount = 0
        self.target = None
        self.mutHits = 0
        if benchFname:
            self._parseBench(benchFname)

    def _parseBench(self, fname):
        logging.debug("Parsing benchmark file %s" % fname)
        self.target = defaultdict(list)
        for row in maxCommon.iterTsvRows(fname):
            self.target[row.Mapping_reference].append(row.HGVS)
            
    def writeMuts(self, docId, status, muts):
        self._updateBenchmark(docId, muts)
        for mut in muts:
            prefixFields=[docId, status]
            self.outFh.write("\t".join(prefixFields)+"\t")
            row = mut.asRow()
            row = [r.replace("\n", " ") for r in row]
            row = [r.replace("\t", " ") for r in row]
            self.outFh.write("\t".join(row))
            self.outFh.write("\n")

    def writeBeds(self, beds):
        for bed in beds:
            self.bedFh.write("\t".join(bed))
            self.bedFh.write("\n")

    def _updateBenchmark(self, docId, muts):
        if self.target==None:
            return

        self.docCount += 1
        refs = self.target[docId]
        for mut in muts:
            self.mutCount += 1
            mutFound = False
            for hgvs in mut.hgvsCoding.split("|"):
                if hgvs in refs:
                    mutFound = True
                    break
            if mutFound:
                self.mutHits += 1

    def printBenchmark(self):
        print "%d documents processed, %d mutations output, %d hits" % (self.docCount, self.mutCount, self.mutHits)

    def close(self):
        self.outFh.close()
        
def main(args, options):
    if options.test:
        import doctest
        doctest.testmod()
        sys.exit(0)

    pubGeneric.setupLogging("", options)
    mutDataDir = join(pubConf.staticDataDir, "mutFinder")

    inFname, outFname = args

    global geneData
    geneData = SeqData(mutDataDir, 9606)
    regexes = parseRegex(mutDataDir)

    writer = OutputWriter(outFname, "mutation_annotations.coding.tab")

    if isfile(inFname):
        findInLocalFile(inFname, writer, regexes)
    elif isdir(inFname):
        findInLocalDir(inFname, writer, regexes)
    else:
        assert(False)

    logging.info("Wrote output to %s" % outFname)

    writer.printBenchmark()
    writer.close()

    #protSizeFname = join(mutDataDir, "uniprot.%s.prot.fa.size")
    #mapAny(protSizeFname, outFname


# === COMMAND LINE INTERFACE, OPTIONS AND HELP ===
parser = optparse.OptionParser("""usage: %prog [options] annotDir - use all possible means to resolve mutations""")

parser.add_option("-d", "--debug", dest="debug", action="store_true", help="show debug messages")
parser.add_option("-v", "--verbose", dest="verbose", action="store_true", help="show more debug messages")
parser.add_option("-t", "--test", dest="test", action="store_true", help="run tests")
(options, args) = parser.parse_args()

if args==[] and not options.test:
    parser.print_help()
    exit(1)

pubGeneric.setupLogging(__file__, options)
main(args, options)
